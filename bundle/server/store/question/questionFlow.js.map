{"version":3,"sources":["../../../../server/store/question/questionFlow.js"],"names":["DEFAULT_QUESTION_FLOW_KEY","QuestionFlow","datahandler","datastore","key","questions","Promise","resolve","_reject","_read","paths","question_flow","then","data","JSON","parse","catch","err","error","stringify","info","_write","anchor","length","findIndex","question","qid","questionID","next","findQidWithAnchor","payload","option","options","find","resp_payload","nextQid","elements","forEach","element","buttons","button"],"mappings":"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","file":"questionFlow.js","sourcesContent":["import logger from 'common/logger';\n\nconst DEFAULT_QUESTION_FLOW_KEY = 'default';\n\nexport default class QuestionFlow {\n  constructor(datahandler) {\n    this.datastore = datahandler.datastore;\n    this.key = null;\n    this.questions = [];\n  }\n\n  load(key = DEFAULT_QUESTION_FLOW_KEY) {\n    this.key = key;\n    return new Promise((resolve, _reject) => {\n      this.datastore._read(this.datastore.paths.question_flow, key)\n        .then((data) => {\n          this.questions = JSON.parse(data);\n          resolve(this);\n        })\n        .catch((err) => {\n          logger.error(`load question flow ${key} failed with ${JSON.stringify(err)}`);\n          logger.info(`create new question flow ${key}`);\n          this.questions = [];\n          resolve(this);\n        });\n    });\n  }\n\n  save(key = DEFAULT_QUESTION_FLOW_KEY) {\n    this.key = key;\n    return this.datastore._write(\n      this.datastore.paths.question_flow,\n      key,\n      JSON.stringify(this.questions),\n    )\n    .then(() => {\n      logger.info(`question flow ${key} saved.`);\n      return this;\n    })\n    .catch((err) => {\n      logger.error(`save question flow ${key} failed with ${JSON.stringify(err)}`);\n      return err;\n    });\n  }\n\n  findQidWithAnchor(anchor) {\n    if (anchor == '#end') {\n      return this.questions.length;\n    } else {\n      return this.questions.findIndex((question) => {\n        return question.anchor && question.anchor == anchor;\n      });\n    }\n  }\n\n  findQuestionWithQid(qid) {\n    if (qid >= 0 && qid < this.questions.length) {\n      return this.questions[qid];\n    } else {\n      return null;\n    }\n  }\n\n  findNextQidOfQuestion(question, questionID) {\n    if (question.next) {\n      return this.findQidWithAnchor(question.next);\n    } else {\n      return questionID + 1;\n    }\n  }\n\n  findNextQidOfQuestionInOptions(question, questionID, payload) {\n    let option = question.options.find((option) => {\n      return option.resp_payload == payload;\n    });\n    if (option && option.next) {\n      return this.findQidWithAnchor(option.next);\n    } else {\n      return questionID + 1;\n    }\n  }\n\n  findNextQidOfQuestionInElements(question, questionID, payload) {\n    var nextQid = null;\n\n    question.elements.forEach((element) => {\n      if (nextQid) {\n        return;\n      }\n\n      if (element.buttons) {\n        let button = element.buttons.find((button) => {\n          return button.next === payload;\n        });\n\n        if (button && button.next) {\n          nextQid = this.findQidWithAnchor(button.next);\n        }\n      }\n    });\n\n    if (nextQid) {\n      return nextQid;\n    } else {\n      return questionID + 1;\n    }\n  }\n}\n"]}