{"version":3,"sources":["../../../server/noAuthEndpoint/webhook.js"],"names":["init","receivedMessage","event","dh","senderID","sender","id","recipientID","recipient","timeOfMessage","timestamp","message","info","JSON","stringify","Promise","all","getQuestionFlow","getUserProgress","getUserResponse","getUserProfile","getAccessToken","then","questionFlow","userProgress","userResponse","userProfile","accessToken","userID","postback","referral","isProfileFetched","page_access_token","get","PAGE_ACCESS_TOKEN_KEY","uri","GRAPH_BASE_URL","qs","profile","update","catch","err","error","expectRespType","stopAtQid","nextQid","confirmationQid","isGoingBack","currentQuestion","findQuestionWithQid","endFire","name","trigger","payload","currentConfirmationId","type","nextExpectRespType","app","WEBHOOK_PATH","req","res","query","send","post","data","body","object","entry","forEach","pageEntry","messaging","messagingEvent","Object","assign","LEADGENBOT_MSG_RECEIVED","sendStatus"],"mappings":";;;;;;;;QAsGgBA,I,GAAAA,I;;AAtGhB;;;;AACA;;;;AACA;;;;AACA;;AACA;;AACA;;AACA;;;;AAEA,SAASC,eAAT,CAAyBC,KAAzB,EAAgCC,EAAhC,EAAoC;AAClC,MAAIC,WAAWF,MAAMG,MAAN,CAAaC,EAA5B;AACA,MAAIC,cAAcL,MAAMM,SAAN,CAAgBF,EAAlC;AACA,MAAIG,gBAAgBP,MAAMQ,SAA1B;AACA,MAAIC,UAAUT,MAAMS,OAApB;;AAEA,mBAAOC,IAAP,CACE,+BAA6BR,QAA7B,kBAAkDG,WAAlD,YAAoEE,aAApE,6BACiBI,KAAKC,SAAL,CAAeH,OAAf,CADjB,CADF;;AAKAI,UAAQC,GAAR,CAAY,CACVb,GAAGc,eAAH,EADU,EAEVd,GAAGe,eAAH,CAAmBd,QAAnB,CAFU,EAGVD,GAAGgB,eAAH,CAAmBf,QAAnB,CAHU,EAIVD,GAAGiB,cAAH,CAAkBhB,QAAlB,CAJU,EAKVD,GAAGkB,cAAH,EALU,CAAZ,EAOCC,IAPD,CAOM,gBAA0E;AAAA;AAAA,QAAxEC,YAAwE;AAAA,QAA1DC,YAA0D;AAAA,QAA5CC,YAA4C;AAAA,QAA9BC,WAA8B;AAAA,QAAjBC,WAAiB;;AAC9E,qBAAOf,IAAP,WAAoBY,aAAaI,MAAjC,qBAAuDf,KAAKC,SAAL,CAAeU,aAAaA,YAA5B,CAAvD;AACA,QAAItB,MAAM2B,QAAN,IAAkB3B,MAAM2B,QAAN,CAAeC,QAArC,EAA+C;AAC7C;AACD;;AAED,QAAI,CAACJ,YAAYK,gBAAZ,EAAL,EAAqC;AACnC;AACA,UAAIC,oBAAoBL,YAAYM,GAAZ,CAAgB,mBAASC,qBAAzB,CAAxB;AACA,uBAAOtB,IAAP,gCAAyCc,YAAYE,MAArD;AACA,0BAAUK,GAAV,CAAc;AACZE,aAAQ,mBAASC,cAAjB,SAAmCV,YAAYE,MADnC;AAEZS,YAAI;AACF,0BAAgBL;AADd;AAFQ,OAAd,EAMCV,IAND,CAMM,UAACgB,OAAD,EAAa;AACjB,yBAAO1B,IAAP,2BAAoCC,KAAKC,SAAL,CAAewB,OAAf,CAApC;AACAZ,oBAAYa,MAAZ,CAAmBD,OAAnB;AACD,OATD,EAUCE,KAVD,CAUO,UAACC,GAAD,EAAS;AACd,yBAAOC,KAAP,gCAA0CD,GAA1C;AACD,OAZD;AAaD;;AAvB6E,gCAyBlBjB,aAAaA,YAzBK;AAAA,QAyBzEmB,cAzByE,yBAyBzEA,cAzByE;AAAA,QAyBzDC,SAzByD,yBAyBzDA,SAzByD;AAAA,QAyB9CC,OAzB8C,yBAyB9CA,OAzB8C;AAAA,QAyBrCC,eAzBqC,yBAyBrCA,eAzBqC;;AA0B9EH,qBAAiBA,kBAAkB,SAAnC;AACAE,cAAUA,WAAW,CAArB;AACA,yCAAmBF,cAAnB,EAAmChC,OAAnC,EAA4CT,KAA5C,EAAmDqB,YAAnD,EAAiEC,YAAjE,EAA+EC,YAA/E,EACGH,IADH,CACQ,iBAA4B;AAAA,UAA1BuB,OAA0B,SAA1BA,OAA0B;AAAA,UAAjBE,WAAiB,SAAjBA,WAAiB;;AAChC;AACA,UAAIC,kBAAkBzB,aAAa0B,mBAAb,CAAiCL,SAAjC,CAAtB;;AAEA,UAAII,gBAAgB9C,KAAhB,GAAsB8C,gBAAgB9C,KAAhB,CAAsBgD,OAA5C,GAAoD,KAAxD,EAA+D;AAC7D,yBAAOtC,IAAP,kCAA2CoC,gBAAgB9C,KAAhB,CAAsBiD,IAAjE;AACA,0BAAMH,gBAAgB9C,KAAhB,CAAsBiD,IAA5B,EAAkCH,eAAlC,EAAmD5C,QAAnD,EAA6D;AAC3DgD,mBAAQ,KADmD;AAE3DC,mBAAQxC,KAAKC,SAAL,CAAeH,OAAf;AAFmD,SAA7D;AAID;;AAED,UAAI2C,wBAAwB,IAA5B;;AAEA,UAAIN,gBAAgBO,IAAhB,IAAwB,cAAxB,IAA0CR,WAA9C,EAA2D;AACzDO,gCAAwBV,SAAxB;AACD,OAFD,MAEO,IAAIE,eAAJ,EAAqB;AAC1BD,kBAAUC,eAAV;AACD;;AAED;AACA,aAAO,mCAAapB,WAAb,EAA0BmB,OAA1B,EAAmCtB,YAAnC,EAAiDE,YAAjD,EACJH,IADI,CACC,iBAAqC;AAAA;AAAA,YAAnCsB,SAAmC;AAAA,YAAxBY,kBAAwB;;AACzChC,qBAAae,MAAb,CAAoB;AAClBI,0BAAgBa,kBADE;AAElBX,mBAASA,OAFS;AAGlBD,qBAAWA,SAHO;AAIlBE,2BAAiBQ;AAJC,SAApB;AAMD,OARI,CAAP;AASD,KA/BH,EAgCGd,KAhCH,CAgCS,UAACC,GAAD,EAAS;AACd,uBAAOC,KAAP,iDAA2DD,GAA3D,SAAkE5B,KAAKC,SAAL,CAAe2B,GAAf,CAAlE;AACA,uBAAO7B,IAAP,CAAY,qCAAZ;AACA;AACA,yCAAac,WAAb,EAA0BmB,OAA1B,EAAmCtB,YAAnC,EAAiDE,YAAjD,EACGH,IADH,CACQ,iBAAqC;AAAA;AAAA,YAAnCsB,SAAmC;AAAA,YAAxBY,kBAAwB;;AACzChC,qBAAae,MAAb,CAAoB;AAClBI,0BAAgBa,kBADE;AAElBX,mBAASA,OAFS;AAGlBD,qBAAWA;AAHO,SAApB;AAKD,OAPH;AAQD,KA5CH;AA6CD,GAhFD;AAiFD;;AAEM,SAAS5C,IAAT,CAAcyD,GAAd,EAAmBtD,EAAnB,EAAuB;AAC5BsD,MAAIxB,GAAJ,CAAQ,mBAASyB,YAAjB,EAA+B,UAACC,GAAD,EAAMC,GAAN,EAAc;AAC3C,QAAID,IAAIE,KAAJ,CAAU,kBAAV,MAAkC,cAAtC,EAAsD;AACpDD,UAAIE,IAAJ,CAASH,IAAIE,KAAJ,CAAU,eAAV,CAAT;AACD,KAFD,MAEO;AACLD,UAAIE,IAAJ,CAAS,+BAAT;AACD;AACF,GAND;;AAQAL,MAAIM,IAAJ,CAAS,mBAASL,YAAlB,EAAgC,UAACC,GAAD,EAAMC,GAAN,EAAc;AAC5C,QAAII,OAAOL,IAAIM,IAAf;AACA,QAAID,KAAKE,MAAL,IAAe,MAAnB,EAA2B;AACzBF,WAAKG,KAAL,CAAWC,OAAX,CAAmB,UAACC,SAAD,EAAe;AAChCA,kBAAUC,SAAV,CAAoBF,OAApB,CAA4B,UAACG,cAAD,EAAoB;AAC9C,cAAIA,eAAe5D,OAAnB,EAA4B;AAC1BV,4BAAgBsE,cAAhB,EAAgCpE,EAAhC;AACD,WAFD,MAEO,IAAIoE,eAAe1C,QAAnB,EAA6B;AAClC5B,4BAAgBuE,OAAOC,MAAP,CAAcF,cAAd,EAA8B;AAC5C5D,uBAAS4D,eAAe1C,QAAf,CAAwBwB;AADW,aAA9B,CAAhB,EAEIlD,EAFJ;AAGD,WAJM,MAIA;AACL,6BAAOS,IAAP,iDAA0DC,KAAKC,SAAL,CAAeyD,cAAf,CAA1D;AACD;AACD,0BAAK,iBAAWG,uBAAhB,EAAyCH,eAAelE,MAAf,CAAsBC,EAA/D;AACD,SAXD;AAYD,OAbD;AAcAsD,UAAIe,UAAJ,CAAe,GAAf;AACD;AACF,GAnBD;AAoBD","file":"webhook.js","sourcesContent":["import logger from 'common/logger';\nimport constant from 'common/constant';\nimport fbrequest from 'common/fbrequest';\nimport {sendQuestion} from 'server/helper/MessengerHelper';\nimport {responseHandlerMap} from 'server/handler/responseHandlers';\nimport {fbtrEvents, fbtr} from 'common/fbtr';\nimport { cfbtr } from 'common/cfbtr';\n\nfunction receivedMessage(event, dh) {\n  let senderID = event.sender.id;\n  let recipientID = event.recipient.id;\n  let timeOfMessage = event.timestamp;\n  let message = event.message;\n\n  logger.info(\n    `Received message for user ${senderID} and page ${recipientID} at ${timeOfMessage} ` +\n    `with message: ${JSON.stringify(message)}`\n  );\n\n  Promise.all([\n    dh.getQuestionFlow(),\n    dh.getUserProgress(senderID),\n    dh.getUserResponse(senderID),\n    dh.getUserProfile(senderID),\n    dh.getAccessToken(),\n  ])\n  .then(([questionFlow, userProgress, userResponse, userProfile, accessToken]) => {\n    logger.info(`user ${userProgress.userID} at progress ${JSON.stringify(userProgress.userProgress)}`);\n    if (event.postback && event.postback.referral) {\n      // TODO: handle user info and referral info here\n    }\n\n    if (!userProfile.isProfileFetched()) {\n      // user profile not found in data store, fetching from graph api\n      var page_access_token = accessToken.get(constant.PAGE_ACCESS_TOKEN_KEY);\n      logger.info(`Fetching user profile for ${userProfile.userID}`);\n      fbrequest.get({\n        uri: `${constant.GRAPH_BASE_URL}/${userProfile.userID}`,\n        qs: {\n          'access_token': page_access_token,\n        },\n      })\n      .then((profile) => {\n        logger.info(`user profile fetched ${JSON.stringify(profile)}`);\n        userProfile.update(profile);\n      })\n      .catch((err) => {\n        logger.error(`Profile fetch failed with ${err}`);\n      });\n    }\n\n    let {expectRespType, stopAtQid, nextQid, confirmationQid} = userProgress.userProgress;\n    expectRespType = expectRespType || 'genesis';\n    nextQid = nextQid || 0;\n    responseHandlerMap[expectRespType](message, event, questionFlow, userProgress, userResponse)\n      .then(({nextQid, isGoingBack}) => {\n        //before going to next question, check if this question requires event to be fired\n        let currentQuestion = questionFlow.findQuestionWithQid(stopAtQid);\n\n        if (currentQuestion.event?currentQuestion.event.endFire:false) {\n          logger.info(`Trigger reply custom event: ${currentQuestion.event.name}.`);\n          cfbtr(currentQuestion.event.name, currentQuestion, senderID, {\n            trigger:'END',\n            payload:JSON.stringify(message)\n          });\n        }\n\n        let currentConfirmationId = null;\n\n        if (currentQuestion.type == 'confirmation' && isGoingBack) {\n          currentConfirmationId = stopAtQid;\n        } else if (confirmationQid) {\n          nextQid = confirmationQid;\n        }\n\n        // we can hanlde this response, go to next question\n        return sendQuestion(userProfile, nextQid, questionFlow, userResponse)\n          .then(([stopAtQid, nextExpectRespType]) => {\n            userProgress.update({\n              expectRespType: nextExpectRespType,\n              nextQid: nextQid,\n              stopAtQid: stopAtQid,\n              confirmationQid: currentConfirmationId,\n            });\n          });\n      })\n      .catch((err) => {\n        logger.error(`Oops, can not handle user response because ${err} ${JSON.stringify(err)}`);\n        logger.info('fall back to re-send last question.');\n        // can not handle this response, repeat last question\n        sendQuestion(userProfile, nextQid, questionFlow, userResponse)\n          .then(([stopAtQid, nextExpectRespType]) => {\n            userProgress.update({\n              expectRespType: nextExpectRespType,\n              nextQid: nextQid,\n              stopAtQid: stopAtQid,\n            });\n          });\n      });\n  });\n}\n\nexport function init(app, dh) {\n  app.get(constant.WEBHOOK_PATH, (req, res) => {\n    if (req.query['hub.verify_token'] === 'TEMPLATE_BOT') {\n      res.send(req.query['hub.challenge']);\n    } else {\n      res.send('Error, wrong validation token');\n    }\n  });\n\n  app.post(constant.WEBHOOK_PATH, (req, res) => {\n    let data = req.body;\n    if (data.object == 'page') {\n      data.entry.forEach((pageEntry) => {\n        pageEntry.messaging.forEach((messagingEvent) => {\n          if (messagingEvent.message) {\n            receivedMessage(messagingEvent, dh);\n          } else if (messagingEvent.postback) {\n            receivedMessage(Object.assign(messagingEvent, {\n              message: messagingEvent.postback.payload,\n            }), dh);\n          } else {\n            logger.info(`Webhook received unsupported messageEvent: ${JSON.stringify(messagingEvent)}`);\n          }\n          fbtr(fbtrEvents.LEADGENBOT_MSG_RECEIVED, messagingEvent.sender.id);\n        });\n      });\n      res.sendStatus(200);\n    }\n  });\n}\n"]}